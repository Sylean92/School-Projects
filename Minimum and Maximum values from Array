########################################################################
# Alyssa Cooke
# COMPSCI 271 HW 4
# April 11 2015
########################################################################
# Main program description:
# 1.Search the array, returning the minimum and maximum values stored in the array.
# 2.Determine how many numbers stored in the array are evenly divisible by 4.
#
########################################################################

	.data
X:  .word 31, 17, 92, 46, 172, 208, 13, 93, 65, 112
N:	.word	10
endl:   .asciiz "\n"
array:	.word	5:0  #array to store numbers divisible by 4

# Fill in additional .asciiz directives for I/O messages here
max:		.asciiz "Maximum value in 10 element array is: "
min:  		.asciiz "Minimum value in 10 element array is: "
divisible:	.asciiz "Values divisible by 4 in 10 element array is: "
#############################################################
#1.Load the address of X into a register (your choice).
#2.Load the value of N into a register (your choice).
#3.Set up the stack frame for MaxMin, then call the MaxMin function.
#4.Display the results from the MaxMin function and clear the MaxMin stack frame.
#5.Set up the stack frame for Div4Count, then call the Div4Count function.
#(You may need to repeat steps 1 and 2 as part of this step.)
#6.Display the result from the Div4Count function.
#7.Return control to the operating system.
##############################################################
	.text
main:
	# 1. Load address of X into a register (e.g., $s0)
	la		$s0, X
	# 2. Load value of N into a register (e.g., $s1)
	lw		$s1, N
	# 3. Set up stack
	addi  $sp, $sp, -20 		#each parameters 0,4,8,12,16,20,24,28,32,36
	sw	  $s0, 0($sp)  			#Store X address into 0(stack 1)
	sw	  $s1, 4($sp)  			# N
	
	# **********Implement MaxMin function ****************************
    # 4. Call the  MaxMin function
	jal  MaxMin
	lw   $s2, 8($sp)
	lw   $s3, 12($sp)  			#returned value
	addi  $sp, $sp, 20  		#de-allocate stack space
	
	# Display lowest number	
	li      $v0, 4
	la      $a0, min
	syscall
	li        $v0, 1        	# system call code for Print Integer
	move      $a0, $s2      	# move value to be printed to $a0
	syscall
	
	li		$v0, 4   			#display string code
	la		$a0, endl
	syscall
	
	# Display largest number
	li      $v0, 4
	la      $a0, max
	syscall
	li        $v0, 1        	# system call code for Print Integer
	move      $a0, $s3      	# move value to be printed to $a0
	syscall
	#****************************************************************
	
	#******** Implement Div4Count function **************************
	addi	$sp, $sp, -8  #allocate 2 more spaces 
	jal  Div4Count
	lw   $s4, 16($sp) #store returned value	
	addi  $sp, $sp, 8 #de-allocate stack space
	

	#***************************************************************
	# End program
	li      $v0, 10
	syscall
	
##############################################
#Description for MaxMin function:
#MaxMin takes two input parameters: (1) the starting memory address 
#of the array, and (2) the number of elements in the array (i.e., its length).
#MaxMin produces two output values: (1) the minimum (lowest) number 
#in the array and (2) the maximum (highest) number in the array.
#
# MaxMin(&X,N,Min,Max)
# $t6 = address of array (X)
# $t1 = number of words in array (N)
# $t3 = minimum value returned in this register
# $t4 = maximum value returned in this register
##############################################
#mn=a[0];
#mx=a[0];
#for(int i=0;i<10;i++)
#	{
#		if(mn>a[i])
#		{
#			mn=a[i];
#		}
#		else if(mx<a[i])
#		{
#			mx = a[i];
#		}
#	}
################################################
	.text
MaxMin:
	lw		$t6, 0($sp)  		#get start address of X
	lw		$t1, 4($sp)  		# get N (size)
	li      $t2, 0   			#counter
	lw		$t5, 0($t6)    		#current element in array
	move	$t3, $t5			#move $t5's value into $t3
	move	$t4, $t5
	
while: 
	bge $t2, $t1, else  				#if counter greater to N go to else
	lw	$t5, 0($t6)
		bge	 $t5,$t3, else2				# if min isn't > $t6[i] go to else2
			move	$t3, $t5  			#store value in array to min register
			addi 	$t6, $t6, 4   		#increment array index
			addi  	$t2, $t2, 1   		#increment i++
			b while
	
		else2:          				#if max < $t6[i]
			ble		$t5, $t4, finish
			move	$t4, $t5  			#store value in array to min register

			finish:
			addi	$t6, $t6, 4
			addi	$t2, $t2, 1
			b while
		
	else:
	sw	$t3, 8($sp)    					# once size of array ends store current values of MAX and MIN
	sw  $t4, 12($sp)
	jr   $ra

########################################################
#Description for Div4Count function
#Div4Count takes two input parameters: (1) the starting memory 
#address of the array, and (2) the number of elements in the array.
#Div4Count produces one output value: the number of array elements 
#that are divisible by 4.
# Div4Count(&X,N,D)
# $t6 = address of array (X)
# $t1 = number of words in array (N)
# $t7 = numbers divisible by 4 returned in this register
#########################################################
	.text
Div4Count:
	lw		$t6, 0($sp)  	#get start address of X
	lw		$t1, 4($sp)  	# get N (size)
	#lw		$s4, 0($t6)     #current element in array
	la		$t7, array		#load empty array to store divisible words
	#move	$s5, $s4		#move $s4's value into $s5	
	li		$s6, 0			#counter
	
	li		$s7, 4          #dividing counter
	
while2:	
	bge $s6, $t1, end  				#if counter greater to N go to end
		div $t6, $s7    			#array[i] mod 4
		mflow $s8					#temp for mod
		beg $s8, 0, mod    			#if temp has no remainder move to mod to store value
		addi	$t6, $t6, 4     	#move to next index in array
		addi	$s6, $s6, 1			#increment counter
		b while2
		
			mod:
			sw 		$t6, $t7		#store value from $t6 into div array
			addi	$t7, $t7, 4		#move index of div array
			addi	$t6, $t6, 4     #move to next index in array
			addi	$s6, $s6, 1		#increment counter
	
			b while2
	
	end:
	sw	$t7, 16($sp)
	jr $ra
		
